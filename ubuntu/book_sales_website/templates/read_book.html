{% extends "base.html" %}

{% block title %}Read {{ book.title }}{% endblock %}

{% block content %}
<div class="container mt-4">
    <h2 class="mb-3">{{ book.title }} <small class="text-muted">by {{ book.author }}</small></h2>
    <div class="alert alert-info">PDF URL: <span id="pdf-url-span">{{ pdf_url }}</span></div>
    <div id="pdf-controls" class="mb-3 d-flex align-items-center justify-content-center">
        <button id="first" class="btn btn-secondary btn-lg me-2">First</button>
        <button id="last" class="btn btn-secondary btn-lg me-2">Last</button>
        <button id="prev" class="btn btn-secondary btn-lg me-2">Previous</button>
        <span>Page <span id="page_num">1</span> / <span id="page_count">?</span></span>
        <button id="next" class="btn btn-secondary btn-lg ms-2">Next</button>
        <input id="goto_page_input" type="number" class="form-control ms-4" style="width:80px;" min="1" placeholder="#">
        <button id="goto_page" class="btn btn-primary btn-lg ms-2">Go</button>
        <button id="original_size" class="btn btn-outline-info btn-lg ms-4">Original</button>
        <button id="zoom_in" class="btn btn-outline-primary btn-lg ms-2">+</button>
        <button id="zoom_out" class="btn btn-outline-primary btn-lg ms-2">-</button>
            <span class="ms-3">Zoom: <span id="zoom-level">100%</span></span>
    </div>
    <div class="d-flex" style="min-height: 70vh;">
            <div id="pdf-viewer" style="overflow-x:auto; width:100%; display:flex; flex-direction:column; align-items:center;">
                <div id="pdf-container" style="position:relative; display:inline-block; margin:24px auto 0 auto;">
                    <canvas id="pdf-canvas" style="border:1px solid #ccc; display:block; background:#fff; box-shadow:0 2px 8px rgba(0,0,0,0.15);"></canvas>
                    <div id="highlight-layer"></div>
                    <div id="text-layer"></div>
                </div>
        </div>
        <!-- PDF.js Text Layer CSS - required for proper text positioning -->
        <style>
            #highlight-layer {
                position: absolute;
                left: 1px;
                top: 1px;
                overflow: visible;
                pointer-events: none;
                z-index: 1;
            }
            #highlight-layer .highlight-rect {
                position: absolute;
                background-color: yellow;
                opacity: 0.5;
                pointer-events: none;
            }
            #highlight-layer .selection-rect {
                position: absolute;
                background-color: rgba(0, 100, 255, 0.4);
                pointer-events: none;
            }
            #manual-selection-box {
                z-index: 9999 !important;
            }
            #text-layer {
                position: absolute;
                left: 1px; /* account for canvas border */
                top: 1px; /* account for canvas border */
                overflow: hidden;
                opacity: 1;
                line-height: 1.0;
                pointer-events: auto;
                z-index: 2;
                cursor: text;
            }
            #text-layer > span {
                color: transparent;
                position: absolute;
                white-space: pre;
                pointer-events: auto;
                transform-origin: 0% 0%;
                user-select: text;
                -webkit-user-select: text;
                -moz-user-select: text;
                background: transparent;
                cursor: text;
            }
            #text-layer > span::selection {
                background-color: rgba(0, 100, 255, 0.4) !important;
            }
            #text-layer > span::-moz-selection {
                background-color: rgba(0, 100, 255, 0.4) !important;
            }
            /* Force selection to show by adding a pseudo-element trick */
            #text-layer {
                mix-blend-mode: multiply;
            }
        </style>
        <div id="search-sidebar" class="ms-4 d-flex flex-column align-items-stretch" style="width:220px; min-height:70vh; border:1px solid #ddd; background:#f9f9f9; padding:16px 12px; border-radius:8px;">
            <div class="mb-2">
                <input id="search_input" type="text" class="form-control mb-2" placeholder="Search text in PDF...">
                <div class="d-flex gap-2">
                    <button id="search_submit" class="btn btn-success flex-grow-1">Find</button>
                    <button id="search_clear" class="btn btn-outline-secondary" style="display:none;">Clear</button>
                </div>
            </div>
            <div id="search_result" class="text-info flex-grow-1" style="white-space:pre-line;"></div>
        </div>
    </div>
    <div class="mt-3">
        <a href="{{ url_for('book_detail', book_id=book.id) }}" class="btn btn-outline-primary">Back to Book Details</a>
    </div>
</div>

<!-- PDF.js ES Module integration -->
<div id="pdfjs-error" style="display:none;color:red;text-align:center;margin-top:1em;"></div>
<!-- Early error capture before module loads -->
<script>
    window._jsErrors = [];
    window.onerror = function(msg, url, line, col, err) {
        window._jsErrors.push({type: 'error', message: msg + ' at ' + url + ':' + line + ':' + col});
        fetch('/js-log', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({type:'error', message: msg + ' at ' + url + ':' + line + ':' + col})});
        return false;
    };
    window.onunhandledrejection = function(e) {
        var msg = 'Unhandled promise rejection: ' + (e.reason && e.reason.message ? e.reason.message : e.reason);
        window._jsErrors.push({type: 'error', message: msg});
        fetch('/js-log', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({type:'error', message: msg})});
    };
    console.log('Early error logging initialized');
    fetch('/js-log', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({type:'info', message: 'Page loaded, early error logging active'})});
</script>
<script type="module">
    import * as pdfjsLib from "{{ url_for('static', filename='js/pdf.mjs') }}";
    // Dynamically load mark.min.js as a classic script
    function loadMarkJs() {
        return new Promise((resolve, reject) => {
            // Check if Mark is already loaded (could be Mark or Mark.default)
            if (window.Mark) {
                const MarkConstructor = window.Mark.default || window.Mark;
                return resolve(MarkConstructor);
            }
            const script = document.createElement('script');
            script.src = "{{ url_for('static', filename='js/mark.min.js') }}";
            script.onload = () => {
                const MarkConstructor = window.Mark && (window.Mark.default || window.Mark);
                if (MarkConstructor) {
                    resolve(MarkConstructor);
                } else {
                    reject(new Error('Mark.js loaded but Mark constructor not found'));
                }
            };
            script.onerror = reject;
            document.head.appendChild(script);
        });
    }
    pdfjsLib.GlobalWorkerOptions.workerSrc = "{{ url_for('static', filename='js/pdf.worker.mjs') }}";
    const url = "{{ pdf_url }}";
    document.getElementById('pdf-url-span').textContent = url;

    let pdfDoc = null;
    let pageNum = 1;
    let pageRendering = false;
    let pageNumPending = null;
    let scale = 1.0;
    
    // Store current page's text content and viewport for selection
    let currentTextContent = null;
    let currentViewport = null;
    
    // Search functionality

    // Use correct IDs for search elements
    let searchBar = document.getElementById('search-sidebar');
    let searchBtn = null; // No dedicated open button, sidebar is always visible
    let searchInput = document.getElementById('search_input');
    let searchSubmit = document.getElementById('search_submit');
    let searchClose = null; // No close button in sidebar
    let searchResult = document.getElementById('search_result');


    // Log to server for diagnostics
    function sendLogToServer(type, message) {
        fetch('/js-log', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({type, message})
        });
    }

    // Edge browser debug log for null elements
    if (!searchBar) { console.warn('searchBar is null'); sendLogToServer('warn', 'searchBar is null'); }
    if (!searchInput) { console.warn('searchInput is null'); sendLogToServer('warn', 'searchInput is null'); }
    if (!searchSubmit) { console.warn('searchSubmit is null'); sendLogToServer('warn', 'searchSubmit is null'); }

    // Global error handler to log JS errors
    window.addEventListener('error', function(e) {
        sendLogToServer('error', e.message + ' at ' + e.filename + ':' + e.lineno + ':' + e.colno);
    });
    window.addEventListener('unhandledrejection', function(e) {
        sendLogToServer('error', 'Unhandled promise rejection: ' + (e.reason && e.reason.message ? e.reason.message : e.reason));
    });


    // No open/close logic for sidebar; always visible

    // --- Manual Drag Selection with visual rectangle ---
    let isDragging = false;
    let dragStartX = 0, dragStartY = 0;
    
    // Create persistent selection rectangle element directly in pdf-container with high z-index
    let selectionBox = document.createElement('div');
    selectionBox.id = 'manual-selection-box';
    selectionBox.style.cssText = `
        position: absolute;
        border: 3px solid #0066ff;
        background-color: rgba(0, 100, 255, 0.25);
        pointer-events: none;
        z-index: 9999;
        display: none;
    `;
    document.getElementById('pdf-container').appendChild(selectionBox);
    
    // Get mouse position relative to pdf-container
    function getMousePos(e) {
        let container = document.getElementById('pdf-container');
        let rect = container.getBoundingClientRect();
        return {
            x: e.clientX - rect.left,
            y: e.clientY - rect.top
        };
    }
    
    // Start drag on mousedown in pdf-container
    document.getElementById('pdf-container').addEventListener('mousedown', function(e) {
        if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT') return;
        
        isDragging = true;
        let pos = getMousePos(e);
        dragStartX = pos.x;
        dragStartY = pos.y;
        
        selectionBox.style.left = dragStartX + 'px';
        selectionBox.style.top = dragStartY + 'px';
        selectionBox.style.width = '0px';
        selectionBox.style.height = '0px';
        selectionBox.style.display = 'block';
        
        e.preventDefault(); // Prevent native text selection
    });
    
    // Update rectangle on mousemove
    document.addEventListener('mousemove', function(e) {
        if (!isDragging) return;
        
        let pos = getMousePos(e);
        let x = Math.min(dragStartX, pos.x);
        let y = Math.min(dragStartY, pos.y);
        let w = Math.abs(pos.x - dragStartX);
        let h = Math.abs(pos.y - dragStartY);
        
        selectionBox.style.left = x + 'px';
        selectionBox.style.top = y + 'px';
        selectionBox.style.width = w + 'px';
        selectionBox.style.height = h + 'px';
    });
    
    // End drag on mouseup - extract text from spans inside the rectangle
    document.addEventListener('mouseup', function(e) {
        if (!isDragging) return;
        isDragging = false;
        
        // Get selection box bounds (relative to pdf-container)
        let boxLeft = parseFloat(selectionBox.style.left);
        let boxTop = parseFloat(selectionBox.style.top);
        let boxWidth = parseFloat(selectionBox.style.width);
        let boxHeight = parseFloat(selectionBox.style.height);
        let boxRight = boxLeft + boxWidth;
        let boxBottom = boxTop + boxHeight;
        
        // Only process if we have a meaningful selection
        if (boxWidth < 5 || boxHeight < 5) {
            selectionBox.style.display = 'none';
            return;
        }
        
        sendLogToServer('info', 'Selection: ' + boxLeft.toFixed(0) + ',' + boxTop.toFixed(0) + ' to ' + boxRight.toFixed(0) + ',' + boxBottom.toFixed(0));
        
        // Use stored text content with PDF coordinate transforms
        // The selection box is relative to pdf-container, which includes the 1px canvas border
        // Adjust for the border offset
        let selLeft = boxLeft - 1;
        let selTop = boxTop - 1;
        let selRight = boxRight - 1;
        let selBottom = boxBottom - 1;
        
        if (!currentTextContent || !currentViewport) {
            sendLogToServer('error', 'No text content available');
            selectionBox.style.display = 'none';
            return;
        }
        
        let selectedTexts = [];
        let items = currentTextContent.items;
        
        for (let i = 0; i < items.length; i++) {
            let item = items[i];
            if (!item.str || item.str.length === 0) continue;
            
            // Get the transform for this text item
            let tx = currentViewport.transform;
            let itemTx = item.transform;
            
            // Calculate position in viewport coordinates
            // The transform is [scaleX, skewY, skewX, scaleY, translateX, translateY]
            let x = itemTx[4] * tx[0] + itemTx[5] * tx[2] + tx[4];
            let y = itemTx[4] * tx[1] + itemTx[5] * tx[3] + tx[5];
            
            // Get dimensions
            let fontSize = Math.sqrt(itemTx[0] * itemTx[0] + itemTx[1] * itemTx[1]);
            let scaledFontSize = fontSize * tx[0];
            let textWidth = item.width * tx[0];
            let textHeight = scaledFontSize;
            
            // PDF coordinates have Y increasing upward, but canvas has Y increasing downward
            // The viewport transform handles this, so y is already in canvas coordinates
            let itemTop = y - textHeight;
            let itemBottom = y;
            let itemLeft = x;
            let itemRight = x + textWidth;
            
            // Check if item intersects with selection
            let itemCenterY = (itemTop + itemBottom) / 2;
            
            if (itemCenterY >= selTop && itemCenterY <= selBottom &&
                itemRight > selLeft && itemLeft < selRight) {
                
                let text = item.str;
                let charWidth = textWidth / text.length;
                
                let startChar = 0;
                let endChar = text.length;
                
                if (selLeft > itemLeft) {
                    startChar = Math.floor((selLeft - itemLeft) / charWidth);
                }
                if (selRight < itemRight) {
                    endChar = Math.ceil((selRight - itemLeft) / charWidth);
                }
                
                startChar = Math.max(0, Math.min(startChar, text.length));
                endChar = Math.max(0, Math.min(endChar, text.length));
                
                if (endChar > startChar) {
                    selectedTexts.push(text.substring(startChar, endChar));
                }
            }
        }
        
        let finalText = selectedTexts.join(' ').trim();
        
        if (finalText) {
            navigator.clipboard.writeText(finalText).then(() => {
                sendLogToServer('info', 'Copied: ' + finalText.substring(0, 100));
                // Show brief feedback
                selectionBox.style.backgroundColor = 'rgba(0, 200, 0, 0.3)';
                setTimeout(() => {
                    selectionBox.style.backgroundColor = 'rgba(0, 100, 255, 0.2)';
                    selectionBox.style.display = 'none';
                }, 500);
                
                // Clear search field and place copied text there
                if (searchInput) {
                    searchInput.value = '';
                    searchInput.value = finalText;
                }
            }).catch(err => {
                sendLogToServer('error', 'Clipboard error: ' + err.message);
                selectionBox.style.display = 'none';
            });
        } else {
            selectionBox.style.display = 'none';
        }
    });

    // --- Highlighting logic ---
    let lastSearchQuery = '';
    // Store highlight rectangles per page: {pageNum: [{left, top, width, height}, ...]}
    let highlightRects = {};

    // Function to draw highlights on the highlight layer (separate from text layer)
    function drawHighlights() {
        let highlightLayer = document.getElementById('highlight-layer');
        // Clear previous highlights
        highlightLayer.innerHTML = '';
        
        if (!lastSearchQuery || !highlightRects[pageNum]) return;
        
        let rects = highlightRects[pageNum];
        rects.forEach(rect => {
            let div = document.createElement('div');
            div.className = 'highlight-rect';
            div.style.left = rect.left + 'px';
            div.style.top = rect.top + 'px';
            div.style.width = rect.width + 'px';
            div.style.height = rect.height + 'px';
            highlightLayer.appendChild(div);
        });
        sendLogToServer('info', 'Drew ' + rects.length + ' highlight rects on page ' + pageNum);
    }

    // Function to calculate highlight positions from PDF text content
    function calculateHighlightsForPage(pageNumCalc, textContent, viewport) {
        if (!lastSearchQuery) return;
        
        let rects = [];
        let searchLower = lastSearchQuery.toLowerCase();
        
        textContent.items.forEach(item => {
            let text = item.str;
            let textLower = text.toLowerCase();
            let idx = textLower.indexOf(searchLower);
            
            if (idx !== -1) {
                // Get transform from PDF coordinates
                let tx = pdfjsLib.Util.transform(viewport.transform, item.transform);
                let left = tx[4];
                let bottom = tx[5];
                let fontSize = Math.sqrt(tx[0] * tx[0] + tx[1] * tx[1]);
                let height = fontSize;
                let top = bottom - height;
                
                // Estimate width based on character position
                let charWidth = item.width / text.length;
                let matchLeft = left + (idx * charWidth);
                let matchWidth = searchLower.length * charWidth;
                
                rects.push({
                    left: matchLeft,
                    top: top,
                    width: matchWidth,
                    height: height
                });
            }
        });
        
        highlightRects[pageNumCalc] = rects;
    }

    if (searchSubmit && searchInput) searchSubmit.addEventListener('click', function() {
        let query = searchInput.value.trim();
        lastSearchQuery = query;
        highlightRects = {}; // Clear previous highlights
        if (!query || !pdfDoc) return;
        searchResult.textContent = 'Searching...';
        let totalMatches = 0;
        let matchedPages = [];
        let promises = [];
        for (let i = 1; i <= pdfDoc.numPages; i++) {
            promises.push(pdfDoc.getPage(i).then(page => {
                let viewport = page.getViewport({scale: scale});
                return page.getTextContent().then(tc => {
                    let text = tc.items.map(item => item.str).join(' ');
                    // Simple case-insensitive search
                    let searchLower = query.toLowerCase();
                    let textLower = text.toLowerCase();
                    let count = 0;
                    let pos = 0;
                    while ((pos = textLower.indexOf(searchLower, pos)) !== -1) {
                        count++;
                        pos += searchLower.length;
                    }
                    if (count > 0) {
                        totalMatches += count;
                        matchedPages.push(i);
                        // Pre-calculate highlights for this page
                        calculateHighlightsForPage(i, tc, viewport);
                    }
                });
            }));
        }
        Promise.all(promises).then(() => {
            if (totalMatches > 0) {
                // Create clickable page links
                let links = matchedPages.map(p => {
                    return `<a href="#" class="search-page-link" data-page="${p}">${p}</a>`;
                }).join(', ');
                searchResult.innerHTML = `Found <b>${totalMatches}</b> match(es) for "${query}" on page(s): ${links}`;
                // Add click listeners
                document.querySelectorAll('.search-page-link').forEach(link => {
                    link.addEventListener('click', function(e) {
                        e.preventDefault();
                        pageNum = parseInt(this.dataset.page);
                        queueRenderPage(pageNum);
                    });
                });
                // Show clear button
                document.getElementById('search_clear').style.display = 'block';
            } else {
                searchResult.textContent = `No results for "${query}".`;
                document.getElementById('search_clear').style.display = 'block';
            }
            // Draw highlights on current page
            drawHighlights();
        });
    });

    // Clear search button
    document.getElementById('search_clear').addEventListener('click', function() {
        searchInput.value = '';
        searchResult.innerHTML = '';
        lastSearchQuery = '';
        highlightRects = {};
        drawHighlights();
        this.style.display = 'none';
    });


    function renderPage(num) {
        let canvas = document.getElementById('pdf-canvas');
        let ctx = canvas.getContext('2d');
        let textLayerDiv = document.getElementById('text-layer');
        let highlightLayer = document.getElementById('highlight-layer');
        pageRendering = true;
        pdfDoc.getPage(num).then(function(page) {
            let viewport = page.getViewport({scale: scale});
            canvas.height = viewport.height;
            canvas.width = viewport.width;
            
            // Store viewport for text selection
            currentViewport = viewport;
            
            // Size and position text layer and highlight layer to match canvas
            textLayerDiv.style.width = viewport.width + 'px';
            textLayerDiv.style.height = viewport.height + 'px';
            highlightLayer.style.width = viewport.width + 'px';
            highlightLayer.style.height = viewport.height + 'px';
            
            let renderContext = {
                canvasContext: ctx,
                viewport: viewport
            };
            let renderTask = page.render(renderContext);
            // Render text layer and calculate highlights
            page.getTextContent().then(function(textContent) {
                // Store text content for text selection
                currentTextContent = textContent;
                
                // Calculate highlight positions from PDF text content
                calculateHighlightsForPage(num, textContent, viewport);
                // Draw highlights
                drawHighlights();
                
                // Remove previous text layer
                while (textLayerDiv.firstChild) textLayerDiv.removeChild(textLayerDiv.firstChild);
                // Use the exported TextLayer class from PDF.js (5.x)
                try {
                    const textLayer = new pdfjsLib.TextLayer({
                        container: textLayerDiv,
                        viewport: viewport,
                        textContentSource: textContent
                    });
                    textLayer.render();
                } catch (err) {
                    sendLogToServer('error', 'TextLayer render error: ' + err.message);
                }
            });
            renderTask.promise.then(function() {
                // No canvas highlight; only use mark.js on text layer
                pageRendering = false;
                document.getElementById('page_num').textContent = num;
                if (pageNumPending !== null) {
                    renderPage(pageNumPending);
                    pageNumPending = null;
                }
            }).catch(function(err) {
                showPdfError('Error rendering page: ' + err.message);
                sendLogToServer('error', 'PDF.js render error: ' + err.message);
            });
        }).catch(function(err) {
            showPdfError('Error loading page: ' + err.message);
            sendLogToServer('error', 'PDF.js page error: ' + err.message);
        });
    }

    function queueRenderPage(num) {
        if (pageRendering) {
            pageNumPending = num;
        } else {
            renderPage(num);
        }
    }

    function onFirstPage() {
        if (pageNum <= 1) return;
        pageNum = 1;
        queueRenderPage(pageNum);
    }
    function onPrevPage() {
        if (pageNum <= 1) return;
        pageNum--;
        queueRenderPage(pageNum);
    }
    function onNextPage() {
        if (pageNum >= pdfDoc.numPages) return;
        pageNum++;
        queueRenderPage(pageNum);
    }
    function onLastPage() {
        if (pageNum >= pdfDoc.numPages) return;
        pageNum = pdfDoc.numPages;
        queueRenderPage(pageNum);
    }
    function updateZoomDisplay() {
        document.getElementById('zoom-level').textContent = Math.round(scale * 100) + '%';
    }
    function onZoomIn() {
        scale = Math.min(scale + 0.2, 3.0);
        updateZoomDisplay();
        queueRenderPage(pageNum);
    }
    function onZoomOut() {
        scale = Math.max(scale - 0.2, 0.5);
        updateZoomDisplay();
        queueRenderPage(pageNum);
    }
    function onOriginalSize() {
        scale = 1.0;
        updateZoomDisplay();
        queueRenderPage(pageNum);
    }
    function onGoToPage() {
        const input = document.getElementById('goto_page_input');
        const targetPage = parseInt(input.value, 10);
        if (isNaN(targetPage) || targetPage < 1 || targetPage > pdfDoc.numPages) {
            alert('Please enter a valid page number (1-' + pdfDoc.numPages + ')');
            return;
        }
        pageNum = targetPage;
        queueRenderPage(pageNum);
        input.value = '';
    }

    function showPdfError(msg) {
        const errDiv = document.getElementById('pdfjs-error');
        errDiv.style.display = 'block';
        errDiv.innerHTML = '<b>PDF Viewer Error:</b> ' + msg + '<br>PDF URL: ' + url;
    }

    // Use pdfjsLib for compatibility
    if (typeof pdfjsLib.getDocument === 'function') {
        console.log('PDF.js version:', pdfjsLib.version || 'unknown');
        console.log('PDF URL:', url);
        // Include wasmUrl for JPEG2000 (JPX) image support
        const loadingTask = pdfjsLib.getDocument({
            url: url,
            wasmUrl: "{{ url_for('static', filename='js/') }}"
        });
        loadingTask.promise.then(function(pdfDoc_) {
            pdfDoc = pdfDoc_;
            document.getElementById('page_count').textContent = pdfDoc.numPages;
            renderPage(pageNum);
        }).catch(function(error) {
            showPdfError('Failed to load PDF: ' + error.message);
            console.error('PDF.js error:', error);
        });
    } else {
        showPdfError('PDF.js library failed to load.');
        console.error('PDF.js library is not available.');
    }

    document.getElementById('first').addEventListener('click', onFirstPage);
    document.getElementById('prev').addEventListener('click', onPrevPage);
    document.getElementById('next').addEventListener('click', onNextPage);
    document.getElementById('last').addEventListener('click', onLastPage);
    document.getElementById('goto_page').addEventListener('click', onGoToPage);
    document.getElementById('goto_page_input').addEventListener('keypress', function(e) {
        if (e.key === 'Enter') onGoToPage();
    });
    document.getElementById('original_size').addEventListener('click', onOriginalSize);
    document.getElementById('zoom_in').addEventListener('click', onZoomIn);
    document.getElementById('zoom_out').addEventListener('click', onZoomOut);
</script>
{% endblock %}
