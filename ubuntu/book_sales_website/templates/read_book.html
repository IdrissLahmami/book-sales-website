{% extends "base.html" %}

{% block title %}Read {{ book.title }}{% endblock %}

{% block content %}
<div class="container mt-4">
    <h2 class="mb-3">{{ book.title }} <small class="text-muted">by {{ book.author }}</small></h2>
    <div class="alert alert-info">PDF URL: <span id="pdf-url-span">{{ pdf_url }}</span></div>
    <div id="pdf-controls" class="mb-3 d-flex align-items-center justify-content-center">
        <button id="prev" class="btn btn-secondary btn-lg me-2">Previous</button>
        <span>Page <span id="page_num">1</span> / <span id="page_count">?</span></span>
        <button id="next" class="btn btn-secondary btn-lg ms-2">Next</button>
        <button id="zoom_in" class="btn btn-outline-primary btn-lg ms-4">+</button>
        <button id="zoom_out" class="btn btn-outline-primary btn-lg ms-2">-</button>
            <span class="ms-3">Zoom: <span id="zoom-level">100%</span></span>
    </div>
    <div class="d-flex" style="min-height: 70vh;">
            <div id="pdf-viewer" style="overflow-x:auto; width:100%; display:flex; flex-direction:column; align-items:center;">
                <canvas id="pdf-canvas" style="border:1px solid #ccc; display:block; margin:24px auto 0 auto; background:#fff; box-shadow:0 2px 8px rgba(0,0,0,0.15); width:auto !important; height:auto !important; max-width:none !important; max-height:none !important;"></canvas>
        </div>
        <div id="search-sidebar" class="ms-4 d-flex flex-column align-items-stretch" style="width:220px; min-height:70vh; border:1px solid #ddd; background:#f9f9f9; padding:16px 12px; border-radius:8px;">
            <div class="mb-2">
                <input id="search_input" type="text" class="form-control mb-2" placeholder="Search text in PDF...">
                <button id="search_submit" class="btn btn-success w-100">Find</button>
            </div>
            <div id="search_result" class="text-info flex-grow-1" style="white-space:pre-line;"></div>
        </div>
    </div>
    <div class="mt-3">
        <a href="{{ url_for('book_detail', book_id=book.id) }}" class="btn btn-outline-primary">Back to Book Details</a>
    </div>
</div>

<!-- PDF.js ES Module integration -->
<div id="pdfjs-error" style="display:none;color:red;text-align:center;margin-top:1em;"></div>
<script type="module">
    import * as pdfjsLib from "{{ url_for('static', filename='js/pdf.mjs') }}";
    pdfjsLib.GlobalWorkerOptions.workerSrc = "{{ url_for('static', filename='js/pdf.worker.mjs') }}";
    const url = "{{ pdf_url }}";
    document.getElementById('pdf-url-span').textContent = url;

    let pdfDoc = null;
    let pageNum = 1;
    let pageRendering = false;
    let pageNumPending = null;
    let scale = 1.0;
    // Search functionality

    let searchBar = document.getElementById('search-bar');
    let searchBtn = document.getElementById('search_btn');
    let searchInput = document.getElementById('search_input');
    let searchSubmit = document.getElementById('search_submit');
    let searchClose = document.getElementById('search_close');
    let searchResult = document.getElementById('search_result');


    // Log to server for diagnostics
    function sendLogToServer(type, message) {
        fetch('/js-log', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({type, message})
        });
    }

    // Edge browser debug log for null elements
    if (!searchBar) { console.warn('searchBar is null'); sendLogToServer('warn', 'searchBar is null'); }
    if (!searchBtn) { console.warn('searchBtn is null'); sendLogToServer('warn', 'searchBtn is null'); }
    if (!searchInput) { console.warn('searchInput is null'); sendLogToServer('warn', 'searchInput is null'); }
    if (!searchSubmit) { console.warn('searchSubmit is null'); sendLogToServer('warn', 'searchSubmit is null'); }

    // Global error handler to log JS errors
    window.addEventListener('error', function(e) {
        sendLogToServer('error', e.message + ' at ' + e.filename + ':' + e.lineno + ':' + e.colno);
    });
    window.addEventListener('unhandledrejection', function(e) {
        sendLogToServer('error', 'Unhandled promise rejection: ' + (e.reason && e.reason.message ? e.reason.message : e.reason));
    });

    if (searchBtn) {
        searchBtn.addEventListener('click', function() {
            searchBar.style.display = 'flex';
            searchInput.focus();
        });
    }
    if (searchClose) {
        searchClose.addEventListener('click', function() {
            searchBar.style.display = 'none';
            searchResult.textContent = '';
            searchInput.value = '';
        });
    }

                        // Update zoom level indicator
                        document.getElementById('zoom-level').textContent = Math.round(scale * 100) + '%';

    // --- Highlighting logic ---
    let lastSearchQuery = '';
    let highlightRects = [];

    searchSubmit.addEventListener('click', function() {
        let query = searchInput.value.trim();
        lastSearchQuery = query;
        highlightRects = [];
        if (!query || !pdfDoc) return;
        searchResult.textContent = 'Searching...';
        let totalMatches = 0;
        let matchedPages = [];
        let promises = [];
        for (let i = 1; i <= pdfDoc.numPages; i++) {
            promises.push(pdfDoc.getPage(i).then(page => {
                return page.getTextContent().then(tc => {
                    let text = tc.items.map(item => item.str).join(' ');
                    let regex = new RegExp(query, 'gi');
                    let pageMatches = (text.match(regex) || []).length;
                    if (pageMatches > 0) {
                        totalMatches += pageMatches;
                        matchedPages.push(i);
                    }
                    // Store highlight rects for current page using precise bounding boxes
                    if (i === pageNum) {
                        highlightRects = [];
                        let textContentItems = tc.items;
                        let pageText = textContentItems.map(item => item.str).join('');
                        let match;
                        let regex2 = new RegExp(query, 'gi');
                        // Build a mapping from global char index to (itemIdx, charIdx)
                        let charMap = [];
                        let globalIdx = 0;
                        for (let i = 0; i < textContentItems.length; i++) {
                            let item = textContentItems[i];
                            for (let j = 0; j < item.str.length; j++) {
                                charMap[globalIdx++] = {itemIdx: i, charIdx: j};
                            }
                        }
                        while ((match = regex2.exec(pageText)) !== null) {
                            let matchStart = match.index;
                            let matchEnd = match.index + match[0].length;
                            // Double-check substring is exact match (avoid false positives)
                            if (pageText.substring(matchStart, matchEnd).toLowerCase() !== query.toLowerCase()) continue;
                            // For each character in the match, get its item and char index
                            let boxes = [];
                            for (let k = matchStart; k < matchEnd; k++) {
                                let map = charMap[k];
                                if (!map) continue;
                                let item = textContentItems[map.itemIdx];
                                let charIdx = map.charIdx;
                                // Calculate per-character width
                                let totalWidth = item.width;
                                let charWidth = totalWidth / item.str.length;
                                let fontHeight = Math.abs(item.transform[3]);
                                let x = item.transform[4] + charWidth * charIdx;
                                let y = item.transform[5] - fontHeight;
                                let w = charWidth;
                                let h = fontHeight;
                                boxes.push({x, y, w, h});
                            }
                            // Merge adjacent boxes into a single rect if possible (for continuous highlights)
                            if (boxes.length > 0) {
                                let merged = [];
                                let cur = boxes[0];
                                for (let i = 1; i < boxes.length; i++) {
                                    let b = boxes[i];
                                    // If adjacent horizontally and on same line, merge
                                    if (Math.abs((cur.x + cur.w) - b.x) < 0.5 && Math.abs(cur.y - b.y) < 1) {
                                        cur.w += b.w;
                                    } else {
                                        merged.push(cur);
                                        cur = b;
                                    }
                                }
                                merged.push(cur);
                                highlightRects.push(...merged);
                            }
                        }
                    }
                });
            }));
        }
        Promise.all(promises).then(() => {
            if (totalMatches > 0) {
                // Create clickable page links
                let links = matchedPages.map(pageNum => {
                    return `<a href="#" class="search-page-link" data-page="${pageNum}">${pageNum}</a>`;
                }).join(', ');
                searchResult.innerHTML = `Found <b>${totalMatches}</b> match(es) for "${query}" on page(s): ${links}`;
                // Add click listeners
                document.querySelectorAll('.search-page-link').forEach(link => {
                    link.addEventListener('click', function(e) {
                        e.preventDefault();
                        pageNum = parseInt(this.dataset.page);
                        queueRenderPage(pageNum);
                    });
                });
            } else {
                searchResult.textContent = `No results for "${query}".`;
            }
            queueRenderPage(pageNum); // re-render to show highlights
        });
    });


    function renderPage(num) {
        let canvas = document.getElementById('pdf-canvas');
        let ctx = canvas.getContext('2d');
        pageRendering = true;
        pdfDoc.getPage(num).then(function(page) {
            let viewport = page.getViewport({scale: scale});
            canvas.height = viewport.height;
            canvas.width = viewport.width;
            let renderContext = {
                canvasContext: ctx,
                viewport: viewport
            };
            let renderTask = page.render(renderContext);
            renderTask.promise.then(function() {
                // Draw highlights if search is active
                if (lastSearchQuery && highlightRects.length > 0) {
                    ctx.save();
                    ctx.globalAlpha = 0.35;
                    ctx.fillStyle = 'yellow';
                    highlightRects.forEach(rect => {
                        // Transform PDF coordinates to canvas
                        let x = rect.x * viewport.transform[0] + viewport.transform[4];
                        let y = rect.y * viewport.transform[3] + viewport.transform[5];
                        let w = rect.w * viewport.transform[0];
                        let h = rect.h * viewport.transform[3];
                        ctx.fillRect(x, y, w, h);
                    });
                    ctx.restore();
                }
                pageRendering = false;
                document.getElementById('page_num').textContent = num;
                if (pageNumPending !== null) {
                    renderPage(pageNumPending);
                    pageNumPending = null;
                }
            }).catch(function(err) {
                showPdfError('Error rendering page: ' + err.message);
                console.error('PDF.js render error:', err);
            });
        }).catch(function(err) {
            showPdfError('Error loading page: ' + err.message);
            console.error('PDF.js page error:', err);
        });
    }

    function queueRenderPage(num) {
        if (pageRendering) {
            pageNumPending = num;
        } else {
            renderPage(num);
        }
    }

    function onPrevPage() {
        if (pageNum <= 1) return;
        pageNum--;
        queueRenderPage(pageNum);
    }
    function onNextPage() {
        if (pageNum >= pdfDoc.numPages) return;
        pageNum++;
        queueRenderPage(pageNum);
    }
    function onZoomIn() {
        scale = Math.min(scale + 0.2, 3.0);
        queueRenderPage(pageNum);
    }
    function onZoomOut() {
        scale = Math.max(scale - 0.2, 0.5);
        queueRenderPage(pageNum);
    }

    function showPdfError(msg) {
        const errDiv = document.getElementById('pdfjs-error');
        errDiv.style.display = 'block';
        errDiv.innerHTML = '<b>PDF Viewer Error:</b> ' + msg + '<br>PDF URL: ' + url;
    }

    // Use pdfjsLib for compatibility
    if (typeof pdfjsLib.getDocument === 'function') {
        console.log('PDF.js version:', pdfjsLib.version || 'unknown');
        console.log('PDF URL:', url);
        pdfjsLib.getDocument(url).promise.then(function(pdfDoc_) {
            pdfDoc = pdfDoc_;
            document.getElementById('page_count').textContent = pdfDoc.numPages;
            renderPage(pageNum);
        }).catch(function(error) {
            showPdfError('Failed to load PDF: ' + error.message);
            console.error('PDF.js error:', error);
        });
    } else {
        showPdfError('PDF.js library failed to load.');
        console.error('PDF.js library is not available.');
    }

    document.getElementById('prev').addEventListener('click', onPrevPage);
    document.getElementById('next').addEventListener('click', onNextPage);
    document.getElementById('zoom_in').addEventListener('click', onZoomIn);
    document.getElementById('zoom_out').addEventListener('click', onZoomOut);
</script>
{% endblock %}
